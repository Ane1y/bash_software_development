## Bash
### Команда: 
- Анеля Дусаева 
- Артемий Лазарев

### Aнализ:

Последовательность действий: 
Ввод пользователя -> Лексер -> Парсер -> Выполнение

**Лексер** разбивает входную строку.
Сначала выделяем лексемы:
 * Строки
   * (str, text)
   * (q, text) - строка в одинарных кавычках, 
   * (dq, text) - строка в двойные кавычках, 
 * Разделители
   * (sp) - пробельные символы (не входящие в кавычки)
   * (eq) - `=`
   * (pipe) - `|`
   * (endl) - конец строки
   * (eof) - конец ввода

Затем сделаем подстановки в `str` и `dq`. Все `str` разбиваем на отдельные лексемы. Для `q` и `dq` заменим метки на `str`.

Если в нашей последовательности лексем, есть последовательные лексемы одного типа, то “склеим” их.	\
`(str, ‘abc’), (str, ‘def’), (sp), (sp), (sp), (endl)` -> `(str, ‘abcdef’), (sp), (endl)`

Полученная последовательность лексем передаётся парсеру.

**Парсер** анализирует входную строку и создаёт составную структуру *Program*:
```python
class Assignment:
    name: str
    value: str

class Cmd:
    text: str
    arguments: List[str]
    prefix: List[Assignment]
    
class Pipeline:
    cmds: List[Cmd]
    
class Program:
	exec: List[Cmd | Assignment | Pipeline]
```

Выполнение команд:
**Раннер** получает структуру от парсера и выполняет их
```python
class Runner:
    program : Program
    run()
```

###  Подводные камни:
- Обработка переменных окружения и передача их внешним командам 
- Циклическое присваивание присваивает ничего (не совсем так) 
- Подстановки выполняются один раз
- Существуют составные лексемы вида:

```shell|bash|console
user@comp:~$ fun()
> {
>   echo "$1"
>   echo "$2"
> }

user@comp:~$ x="a a"
user@comp:~$ fun $x'$x'"$x"
a
a$xa a
```
